// import { AnnotationFactory, TestingReflectContext } from '@aspectjs/common';
// import { configureReflectTestingContext } from '@aspectjs/common/testing';
// import { configureAspectTestingContext } from '@aspectjs/core/testing';
// import type { ConstructorType } from 'packages/common/src/constructor.type';
// import { Aspect } from './aspect.annotation';
// import { AspectModule } from './aspect.module';
// import type { AspectRegistry } from './__aspect.registry';
// import type { AspectType } from './aspect.type';

// describe('AspectModule', () => {
//   let context!: TestingReflectContext;
//   beforeEach(() => {
//     context?.reset();
//     context = configureReflectTestingContext(new AspectModule());
//   });
//   it('adds a new AspectRegistry provider to the ReflectContext', () => {
//     expect(context.has('aspectRegistry'));
//   });
// });

// describe('AspectRegistry', () => {
//   let context!: TestingReflectContext;
//   let aspectRegistry!: AspectRegistry;
//   let TestAspect!: ConstructorType<AspectType>;

//   beforeEach(() => {
//     context?.reset();
//     context = configureAspectTestingContext();
//     aspectRegistry = context.get('aspectRegistry');
//   });

//   describe('.find(aspectId: string)', () => {
//     describe('when @Aspect(aspectId) exists', () => {
//       beforeEach(() => {
//         @Aspect('testAspect')
//         class _TestAspect {}
//         TestAspect = _TestAspect;
//       });
//       it('returns the aspect and its options', () => {
//         const entry = aspectRegistry.find('testAspect');

//         expect(entry?.aspect).toEqual(TestAspect);
//         expect(entry?.options).toEqual({
//           id: 'testAspect',
//         });
//       });
//     });

//     describe('when @Aspect(aspectId) does not exist', () => {
//       beforeEach(() => {
//         @Aspect()
//         class _TestAspect {}
//         TestAspect = _TestAspect;
//       });
//       it('returns undefined', () => {
//         const entry = aspectRegistry.find('do-not-exists');

//         expect(entry).toBeUndefined();
//       });
//     });
//   });

//   describe('.find(aspect: class)', () => {
//     describe('when given class is annotated with  @Aspect(options: object)', () => {
//       beforeEach(() => {
//         @Aspect({
//           id: 'testAspect',
//         })
//         class _TestAspect {}
//         TestAspect = _TestAspect;
//       });
//       it('returns the aspect and its options', () => {
//         const entry = aspectRegistry.find(TestAspect);

//         expect(entry?.aspect).toEqual(TestAspect);
//         expect(entry?.options).toEqual({
//           id: 'testAspect',
//         });
//       });
//     });

//     describe('when given class is annotated with  @Aspect(<empty>)', () => {
//       beforeEach(() => {
//         @Aspect()
//         class _TestAspect {}
//         TestAspect = _TestAspect;
//       });
//       it('returns the aspect', () => {
//         const entry = aspectRegistry.find(TestAspect);

//         expect(entry?.aspect).toEqual(TestAspect);
//       });
//     });

//     describe('when given class is not annotated with @Aspect()', () => {
//       beforeEach(() => {
//         const Test = new AnnotationFactory('test').create(function Test() {});
//         @Test()
//         class _TestAspect {}
//         TestAspect = _TestAspect;
//       });
//       it('returns undefined', () => {
//         const entry = aspectRegistry.find(TestAspect);

//         expect(entry).toBeUndefined();
//       });
//     });
//   });
// });
